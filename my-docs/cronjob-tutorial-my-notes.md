# Intro

The job (no pun intended) of the ***CronJob* controller** is to run one-off tasks on the Kubernetes cluster at regular intervals. It does this by building on top of the *Job* controller, whose task is to run one-off tasks once, seeing them to completion.

>  So I guess that we will have custom resource definition of new Kind **Cronjob** with some task and interval defined.

# Scaffold structure

- `go.mod` - dependencies
- `Makefile` - Make targets for building and deploying controller
- `PROJECT` - metadata about project

## go.mod

Obvious standard go file. All dependencies that kubebuilder uses.

## Makefile

Has defined:

- image name to use to all new images builded
- container tool (set to Docker by default)

PHONY is a makefile keyword to mark commands. Originally makefile is used to manage how files are generated from other files. However we sometimes use makefile to run commands like `install`, `clean`, `test`, `run`.  These are typically actions that you want to perform, rather than names of files to be generated. These targets are not filenames.  If you don't declare these non-file targets as `.PHONY`, and a file with the same name as the target exists in the directory, `Make` might get confused and not run your commands. By declaring a target as phony, you tell Make to ignore the file system and always run the commands associated with this target.

## PROJECT

```
# Code generated by tool. DO NOT EDIT.
# This file is used to track the info used to scaffold your project
# and allow the plugins properly work.
# More info: https://book.kubebuilder.io/reference/project-config.html
domain: tutorial.kubebuilder.io
layout:
- go.kubebuilder.io/v4
projectName: project
repo: tutorial.kubebuilder.io/project
resources:
- api:
    crdVersion: v1
    namespaced: true
  controller: true
  domain: tutorial.kubebuilder.io
  group: batch
  kind: CronJob
  path: tutorial.kubebuilder.io/project/api/v1
  version: v1
  webhooks:
    defaulting: true
    validation: true
    webhookVersion: v1
version: "3"
```

## config/

We also get launch configurations under the [`config/`](https://github.com/kubernetes-sigs/kubebuilder/tree/master/docs/book/src/cronjob-tutorial/testdata/project/config) directory.

Right now, it just contains [Kustomize](https://sigs.k8s.io/kustomize) YAML definitions required to launch our controller on a cluster, but once we get started writing our controller, it’ll also hold our CustomResourceDefinitions, RBAC configuration, and WebhookConfigurations.

> What is Kustomize? https://github.com/kubernetes-sigs/kustomize
>
> `kustomize` lets you customize raw, template-free YAML files for multiple purposes, leaving the original YAML untouched and usable as is.
>
> `kustomize` targets kubernetes; it understands and can patch [kubernetes style](https://kubectl.docs.kubernetes.io/references/kustomize/glossary/#kubernetes-style-object) API objects. It's like [`make`](https://www.gnu.org/software/make), in that what it does is declared in a file, and it's like [`sed`](https://www.gnu.org/software/sed), in that it emits edited text.
>
> How it works?
>
> In some directory containing your YAML [resource](https://kubectl.docs.kubernetes.io/references/kustomize/glossary/#resource) files (deployments, services, configmaps, etc.), create a [kustomization](https://kubectl.docs.kubernetes.io/references/kustomize/glossary/#kustomization) file.
>
> This file should declare those resources, and any customization to apply to them, e.g. *add a common label*.
>
> ```yaml
> apiVersion: kustomize.config.k8s.io/v1beta1
> kind: Kustomization
> commonLabels:
> 	app: myapp 
> resources:
> 	deployment.yaml
> 	service.yaml
> ```
>
> After you apply the file above on some directory (containing `deployment.yaml` and `service.yaml`) it will add common label `app:myapp` to them.

Each other directory contains a different piece of configuration, refactored out into its own base:

- [`config/manager`](https://github.com/kubernetes-sigs/kubebuilder/tree/master/docs/book/src/cronjob-tutorial/testdata/project/config/manager): launch your controllers as pods in the cluster
- [`config/rbac`](https://github.com/kubernetes-sigs/kubebuilder/tree/master/docs/book/src/cronjob-tutorial/testdata/project/config/rbac): permissions required to run your controllers under their own service account

# main.go

```go
package main

import (
    "flag"
    "os"

    // Import all Kubernetes client auth plugins (e.g. Azure, GCP, OIDC, etc.)
    // to ensure that exec-entrypoint and run can make use of them.
    _ "k8s.io/client-go/plugin/pkg/client/auth"

    "k8s.io/apimachinery/pkg/runtime"
    utilruntime "k8s.io/apimachinery/pkg/util/runtime"
    clientgoscheme "k8s.io/client-go/kubernetes/scheme"
    _ "k8s.io/client-go/plugin/pkg/client/auth/gcp"
    ctrl "sigs.k8s.io/controller-runtime"
    "sigs.k8s.io/controller-runtime/pkg/cache"
    "sigs.k8s.io/controller-runtime/pkg/healthz"
    "sigs.k8s.io/controller-runtime/pkg/log/zap"
    "sigs.k8s.io/controller-runtime/pkg/metrics/server"
    "sigs.k8s.io/controller-runtime/pkg/webhook"
    // +kubebuilder:scaffold:imports
)
```

Our package starts out with some basic imports. Particularly:

- The core [controller-runtime](https://pkg.go.dev/sigs.k8s.io/controller-runtime?tab=doc) library imported as `ctrl`
- The default controller-runtime logging, [Zap](https://pkg.go.dev/go.uber.org/zap) (more on that a bit later)

> **controller-runtime** - The Kubernetes controller-runtime Project is a set of go libraries for building Controllers. It is leveraged by [Kubebuilder](https://book.kubebuilder.io/) and [Operator SDK](https://github.com/operator-framework/operator-sdk). Both are a great place to start for new projects.

```go
var (
    scheme   = runtime.NewScheme()
    setupLog = ctrl.Log.WithName("setup")
)
```

Every set of controllers needs a [*Scheme*](https://book.kubebuilder.io/cronjob-tutorial/gvks#err-but-whats-that-scheme-thing), which provides mappings between Kinds and their corresponding Go types. We’ll talk a bit more about Kinds when we write our API definition, so just keep this in mind for later.

```go
func init() {
    utilruntime.Must(clientgoscheme.AddToScheme(scheme)) //we tell the util runtime that it must add our scheme variable to its client-go

    //+kubebuilder:scaffold:scheme
}
```

> golang::init() is called at the beginning of any package (even before main). When you import a package its init func is called.
>
> **client-go** - Go clients for talking to a [kubernetes](http://kubernetes.io/) cluster. https://github.com/kubernetes/client-go. K8s API client is a program that talks with cluster's kube-api-server

```go
func main() {
    // 1 --------------------------------------------
    var metricsAddr string
    var enableLeaderElection bool
    var probeAddr string
    flag.StringVar(&metricsAddr, "metrics-bind-address", ":8080", "The address the metric endpoint binds to.")
    flag.StringVar(&probeAddr, "health-probe-bind-address", ":8081", "The address the probe endpoint binds to.")
    flag.BoolVar(&enableLeaderElection, "leader-elect", false,
        "Enable leader election for controller manager. "+
            "Enabling this will ensure there is only one active controller manager.")
    // 2 --------------------------------------------
    opts := zap.Options{
        Development: true,
    }
    opts.BindFlags(flag.CommandLine)
    flag.Parse()

    ctrl.SetLogger(zap.New(zap.UseFlagOptions(&opts)))
    // 3 --------------------------------------------
    mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
        Scheme: scheme,
        Metrics: server.Options{
            BindAddress: metricsAddr,
        },
        WebhookServer:          webhook.NewServer(webhook.Options{Port: 9443}),
        HealthProbeBindAddress: probeAddr,
        LeaderElection:         enableLeaderElection,
        LeaderElectionID:       "80807133.tutorial.kubebuilder.io",
    })
    if err != nil {
        setupLog.Error(err, "unable to start manager")
        os.Exit(1)
    }
```

## 1

We setup some flags for metrics. Metrics that inform about the health of controller. Controller will open ports on which he will start HTTP server for such cause. 

## 2

Setup a logger

## 3

We instantiate a [*manager*](https://pkg.go.dev/sigs.k8s.io/controller-runtime/pkg/manager?tab=doc#Manager), which keeps track of running all of our controllers, as well as setting up shared caches and clients to the API server (notice we tell the manager about our Scheme).

We run our manager, which in turn runs all of our controllers and webhooks. The manager is set up to run until it receives a graceful shutdown signal. This way, when we’re running on Kubernetes, we behave nicely with graceful pod termination.

> **Manager** - Manager initializes shared dependencies such as Caches and Clients, and provides them to Runnables. A Manager is required to create Controllers. https://pkg.go.dev/sigs.k8s.io/controller-runtime/pkg/manager#Manager. 
>
> Start method of a Manager: Start starts all registered Controllers and blocks until the context is cancelled.

> **Webhook** - A webhook is an HTTP request, triggered by an event in a source system and sent to a destination system, often with a payload of data.
> ![](img/1.png)

# Creating the API
https://book.kubebuilder.io/cronjob-tutorial/new-api


First, get familiar with [api-gvk-101](api-gvk.101.md). What does it mean to add an API?

We use API Objects to tell our K8s Cluster what do we want to obtain. The API Objects reflect the business logic.
How we can CRUD these API Objects? Via REST API accessible to us via kube-api-server. Every API object has a set of 4 endpoints that allow you to Create, Read, Update, Delte it. When you register your own kind/type of API object you need to also define this API.
You need to create API that will allow to CRUD your kind of API Object - Your custom resource.

The command:
```sh
kubebuilder create api --group batch --version v1 --kind CronJob
```
Run it. Answer yes two times.

Lets discuss the changes that occured. New files, files modifications etc.
![](img/2.png)

## `api/v1`
Our new kind Cronjob specifies several go types. All of these type are placed in [cronjob_types.go](../api/v1/cronjob_types.go)

[groupversion_info.go](../api/v1/groupversion_info.go) - here is some info about our gvk to we can properly build Schema object and register it.

[zz_generated.deepcopy.go](../api/v1/zz_generated.deepcopy.go) you know what deep copy in go is?

###  [cronjob_types.go](../api/v1/cronjob_types.go)

Has few structs, they correspod to the Kind:

- `spec` - spec of the Kind instance in k8s is its desired state, it is the info in yaml definition file, it *spec*ifies what we want the resource to be. 
- `status` - is the current state of Kind instance (resource). Kubernetes observes the **status** and compares it to **spec**. Then reconciles both. 
- `root type` - describes the Kind. It has spec and status in itself and some common for all Kinds metadata
- `list` - container for list of root type objects

root type:
```go
//+kubebuilder:object:root=true
//+kubebuilder:subresource:status

// CronJob is the Schema for the cronjobs API
type CronJob struct {
    metav1.TypeMeta   `json:",inline"`				 // Contains strings: Kind and ApiVersion
    metav1.ObjectMeta `json:"metadata,omitempty"`    // Contains strings: Name, Namespace, Labels, CreationTimestamp, etc.

    Spec   CronJobSpec   `json:"spec,omitempty"`     // specification of CronJob in its desired state
    Status CronJobStatus `json:"status,omitempty"`   // current status of the CronJob (controller will compare it to Spec and reconcile) 
}
```

package `"k8s.io/apimachinery/pkg/apis/meta/v1"` imported as `metav1` contains some metadata common to all k8s kinds.

In this file you the designer of kind will define its spec and status.

### [groupversion_info.go](../api/v1/groupversion_info.go) 
Here we define variables for `SchemeBuilder` which we use to build the Scheme object. As you can see we declare this var as a reference of struct `Builder` from `scheme` package. 

At the end of [cronjob_types.go](../api/v1/cronjob_types.go)  we use this variable:
```go
func init() {
	SchemeBuilder.Register(&CronJob{}, &CronJobList{})
}
```

## `internal/controller`
### [cronjob_controller.go](cronjob_controller.go)
The actual mission of k8s controller (of any k8s object) is actually to RECONCILE.
That's why the main body of controller is called `reconciler` and the main method is `reconcile`.
The other method is used to register this reconciler with given manager.

## `cmd/main.go`
Here we have few more lines added:
```go
if err = (&controller.CronJobReconciler{
		Client: mgr.GetClient(),
		Scheme: mgr.GetScheme(),
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "CronJob")
		os.Exit(1)
	}
```
These lines create an instance of `CronJobReconciler` struct. The stcut is filled with fields for Client and Scheme. Also we have a method to add the rigth manager. See [elements-of-controller-runtime.md](elements-of-controller-runtime.md).
